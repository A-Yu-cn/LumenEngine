#include "Game/Asset/Public/Scene.h"
#include "Render/RenderCore/Public/RenderCommand.h"

using namespace Lumen::Game;
using namespace Lumen::Render;

Scene::Scene()
{

}

bool Scene::CreateEntity(std::string_view className)
{
	rttr::type derivedType = rttr::type::get_by_name(className.data());
	if (!derivedType.is_valid()) return false;

	// Note variant manage data life itself, we need to set consistent data to shared_ptr
	variant derived = derivedType.create();
	Entity* d = derived.get_value<Entity*>();

	std::shared_ptr<Entity> consistentEntity = std::make_shared<Entity>();
	rttr::instance entityRef(consistentEntity);

	FillEntityInternal(derivedType, entityRef, derived);
	consistentEntity->SetName(className.data() + std::string("_") + std::to_string(nameIndex++));

	entities.emplace_back(consistentEntity);

	ENQUEUE_RENDER_COMMAND("CreateRenderItem", [entityProxy = Entity(*consistentEntity.get())](RHIContext* graphicsContext) {
		graphicsContext->CreateRenderItem(entityProxy);
	});

	return true;
}

void Scene::DeleteEntity(std::string_view name)
{
	for (int i = 0; i < entities.size(); i++)
	{
		if (entities[i]->GetName() == name.data())
		{
			auto guid = entities[i]->GetGuid().str();
			ENQUEUE_RENDER_COMMAND("RemoveRenderItem", [guid](RHIContext* graphicsContext) {
				graphicsContext->RemoveRenderItem(guid);
			});

			entities[i].reset();
			entities.erase(entities.begin() + i);
			break;
		}
	}
}

void Scene::FillEntityInternal(const rttr::type& t, rttr::instance dstObj, const rttr::instance& srcObj)
{
	for (auto& p : t.get_properties(filter_item::instance_item | filter_item::non_public_access | filter_item::public_access))
	{
		if (p.get_metadata("serialize").is_valid() && p.get_metadata("serialize").to_bool())
		{
			variant var = p.get_value(srcObj);
			p.set_value(dstObj, var);
		}
	}
}

// This following is generated by Ubpa::USRefl::AutoRefl

RTTR_REGISTRATION
{
	registration::class_<Lumen::Game::Scene>("Scene")
		.constructor<>()
		.property("camera", &Scene::camera)
		(
			metadata("serialize", true)
		)
		.property("light", &Scene::light)
		(
			metadata("serialize", true)
		)
		.property("entities", &Scene::entities)
		(
			metadata("serialize", true)
		)
	;
}