#include "Game/Asset/Public/Scene.h"
#include "Render/RenderCore/Public/RenderCommand.h"

using namespace Lumen::Game;
using namespace Lumen::Render;

Scene::Scene()
{

}

Entity* Scene::CreateEntity(std::string_view className)
{
	rttr::type derivedType = rttr::type::get_by_name(className.data());
	if (!derivedType.is_valid()) return nullptr;

	// Note variant manage data life itself, we need to persistent data with shared_ptr
	variant derived = derivedType.create();
	auto entity = derived.get_value<std::shared_ptr<Entity>>();
	entity->SetName(className.data() + std::string("_") + std::to_string(nameIndex++));

	if (entity->GetMeshContainer())
		CreateEntityOnRender(entity);

	entityMap.emplace(entity->GetGuid(), entities.size());
	entities.emplace_back(entity);

	return entities.back().get();
}

void Scene::CreateEntityOnRender(std::shared_ptr<Entity> entity)
{
	ENQUEUE_RENDER_COMMAND("CreateEntity", [entity](RHIContext* graphicsContext) {
		const Entity entityProxy(*entity);
		const MeshComponent meshContainer(*entity->GetMeshContainer());
		const MeshRendererComponent meshRenderer(*entity->GetMeshRenderer());
		graphicsContext->CreateEntity(entityProxy, meshContainer, meshRenderer);
	});
}

void Scene::UpdateEntity(Entity* entity)
{
	if (entity->GetMeshContainer() && entity->GetMeshRenderer())
		ENQUEUE_RENDER_COMMAND("UpdateEntity", [entity](RHIContext* graphicsContext) {
			const Entity entityProxy(*entity);
			const MeshComponent meshContainer(*entity->GetMeshContainer());
			const MeshRendererComponent meshRenderer(*entity->GetMeshRenderer());
			graphicsContext->UpdateEntity(entityProxy, meshContainer, meshRenderer);
		});
}

void Scene::DeletePendingEntities()
{
	for (auto& entity : entities)
	{
		if (entity && entity->IsPendingDestroy())
		{
			auto guid = entity->GetGuid().str();
			ENQUEUE_RENDER_COMMAND("RemoveRenderItem", [guid](RHIContext* graphicsContext) {
				graphicsContext->RemoveRenderItem(guid);
			});

			entityMap.erase(entity->GetGuid());
			entity.reset();
		}
	}
}

void Scene::SortEntityList()
{
	std::vector<std::shared_ptr<Entity>> newEntities;
	std::unordered_map<xg::Guid, size_t> newEntityMap;

	newEntities.reserve(entities.size());
	for (int i = 0; i < entities.size(); i++)
	{
		if (entities[i] && !entities[i]->IsPendingDestroy())
		{
			newEntityMap.emplace(entities[i]->GetGuid(), newEntities.size());
			newEntities.emplace_back(std::move(entities[i]));
		}
	}
	int a = 1;
	entities.clear();
	entities = std::move(newEntities);
	entityMap = std::move(newEntityMap);
}

// This following is generated by Ubpa::USRefl::AutoRefl

RTTR_REGISTRATION
{
	registration::class_<Lumen::Game::Scene>("Scene")
		.constructor<>()
		.method("CreateEntity", &Scene::CreateEntity)
		.method("UpdateEntity", &Scene::UpdateEntity)
		.property("entities", &Scene::entities)
		(
			metadata("serialize", true)
		)
		.property("nameIndex", &Scene::nameIndex)
	;
}