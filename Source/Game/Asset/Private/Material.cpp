#include "Game/Asset/Public/Material.h"
#include "Core/Math/Public/MathUtil.h"

using namespace Lumen::Game;

PropertyList::PropertyList()
{

}

Material::Material()
{

}

Material::Material(const Material& rhs)
{
	name = rhs.name;
	path = rhs.path;
	guid = rhs.guid;
	shaderlab = rhs.shaderlab;
	propertyList = rhs.propertyList;
	propertyOffsetMap = rhs.propertyOffsetMap;
	propertyListSize = rhs.propertyListSize;
	bOffsetMapInitialized = rhs.bOffsetMapInitialized;
	buffer = (uint8_t*)malloc(propertyListSize * sizeof(uint8_t));
	memcpy(buffer, rhs.buffer, propertyListSize * sizeof(uint8_t));
}

Material::Material(Material&& rhs)
{
	name = std::move(rhs.name);
	path = std::move(rhs.path);
	guid = std::move(rhs.guid);
	shaderlab = std::move(rhs.shaderlab);
	propertyList = std::move(rhs.propertyList);
	propertyOffsetMap = std::move(rhs.propertyOffsetMap);
	propertyListSize = rhs.propertyListSize;
	bOffsetMapInitialized = rhs.bOffsetMapInitialized;
	buffer = rhs.buffer;
	rhs.buffer = nullptr;
}

Material::~Material()
{
	free(buffer);
}

void Material::InitBuffer(ShaderLab* shader)
{
	int propIndex = 0;  // Because string type does not participate in buffer, set an individual counter
	for (const auto& prop : shader->properties)
	{
		auto index = prop.value.index();
		if (index == 0)      // int
			propertyOffsetMap.emplace(prop.name, shader->offsets[propIndex++]);
		else if (index == 1) // float
			propertyOffsetMap.emplace(prop.name, shader->offsets[propIndex++]);
		else if (index == 2) // vec4
			propertyOffsetMap.emplace(prop.name, shader->offsets[propIndex++]);
	}
	propertyListSize = shader->propertyCapacity;
	bOffsetMapInitialized = true;
	buffer = (uint8_t*)malloc(propertyListSize * sizeof(uint8_t));
}

void Material::UpdateBuffer()
{
	for (const auto& v : propertyList.integerMap)
	{
		uint32_t offset = propertyOffsetMap.at(v.first);
		memcpy(&buffer[offset], &v.second, sizeof(int));
	}
	for (const auto& v : propertyList.floatMap)
	{
		uint32_t offset = propertyOffsetMap.at(v.first);
		memcpy(&buffer[offset], &v.second, sizeof(float));
	}
	for (const auto& v : propertyList.colorMap)
	{
		uint32_t offset = propertyOffsetMap.at(v.first);
		Float4 num; num.x = v.second.x, num.y = v.second.y, num.z = v.second.z; num.w = v.second.w;
		memcpy(&buffer[offset], &num, sizeof(Float4));
	}
}

// This following is generated by Ubpa::USRefl::AutoRefl

RTTR_REGISTRATION
{
	registration::class_<Lumen::Game::PropertyList>("PropertyList")
		.constructor<>()
		.property("texMap", &PropertyList::texMap)
		(
			metadata("serialize", true)
		)
		.property("integerMap", &PropertyList::integerMap)
		(
			metadata("serialize", true)
		)
		.property("floatMap", &PropertyList::floatMap)
		(
			metadata("serialize", true)
		)
		.property("colorMap", &PropertyList::colorMap)
		(
			metadata("serialize", true)
		)
	;
	registration::class_<Lumen::Game::Material>("Material")
		.constructor<>()
		.constructor<const Material&>()
		.constructor<Material&&>()
		.method("InitBuffer", &Material::InitBuffer)
		.method("UpdateBuffer", &Material::UpdateBuffer)
		.property("name", &Material::name)
		.property("guid", &Material::guid)
		.property("shaderlab", &Material::shaderlab)
		(
			metadata("serialize", true)
		)
		.property("propertyList", &Material::propertyList)
		(
			metadata("serialize", true)
		)
		.property("propertyListSize", &Material::propertyListSize)
		.property("propertyOffsetMap", &Material::propertyOffsetMap)
		.property("bOffsetMapInitialized", &Material::bOffsetMapInitialized)
		.property("buffer", &Material::buffer)
	;
}