#include "Game/GamePlay/Public/Camera.h"

using namespace Lumen::Game;

Camera::Camera()
{

}

Camera::Camera(float fov, float aspect, float nearPlane, float farPlane)
{
	mFov = fov;
	mAspectRatio = aspect;
	mNearPlane = nearPlane;
	mFarPlane = farPlane;

	UpdateProjMatrix();
	Update();
}

void Camera::Update()
{
	Vec3 pos = mTransform.position;
	mViewMatrix = MathUtil::LookAt(pos, pos + mFront, mWorldUp);
	mViewProjMatrix = mProjMatrix * mViewMatrix;
}

void Camera::UpdateProjMatrix()
{
	float angle = MathUtil::Angle2Radian(mFov);
	float top = tan(angle / 2.f) * mNearPlane;
	float bottom = -top;
	float right = top * mAspectRatio;
	float left = -right;

	float arrOrthoTranslate[16] = { 1, 0, 0, -(left + right) / 2.f,
										  0, 1, 0, -(top + bottom) / 2.f,
										  0, 0, 1, -(mNearPlane + mFarPlane) / 2.f,
										  0, 0, 0, 1 };
	Mat4 orthoTranslate(arrOrthoTranslate);
	float arrOrthoScale[16] = { 2.f / (right - left), 0, 0, 0,
										  0, 2.f / (top - bottom), 0, 0,
										  0, 0, 2.f / (mFarPlane - mNearPlane), 0,
										  0, 0, 0, 1 };
	Mat4 orthoScale(arrOrthoScale);
	float arrOrtho2Perspective[16] = { mNearPlane, 0, 0, 0,
										  0, mNearPlane, 0, 0,
										  0, 0, mNearPlane + mFarPlane, -mNearPlane * mFarPlane,
										  0, 0, 1, 0 };
	Mat4 proj2ortho(arrOrtho2Perspective);
	Mat4 orthoMatrix = orthoScale * orthoTranslate;

	mProjMatrix = orthoMatrix * proj2ortho;
}

void Camera::ProcessKeyboard()
{
	if (deviceStatus->bSceneWindow && deviceStatus->rightMouseActive)
	{
		if (deviceStatus->wPressed)
			mTransform.position += mFront * mMoveSpeed;
		if (deviceStatus->sPressed)
			mTransform.position -= mFront * mMoveSpeed;
		if (deviceStatus->aPressed)
			mTransform.position -= mRight * mMoveSpeed;
		if (deviceStatus->dPressed)
			mTransform.position += mRight * mMoveSpeed;
	}
	Update();
}

void Camera::ProcessMouseMovement()
{
	if (deviceStatus->bSceneWindow && deviceStatus->rightMouseActive)
	{
		float sign = mUp.y > 0 ? -1.0f : 1.0f;
		mYaw += sign * deviceStatus->delta.x;
		mPitch += deviceStatus->delta.y;

		UpdateRotateVector();
		Update();
	}
}

void Camera::UpdateRotateVector()
{
	// Calculate the new front vector
	Vec3 newFront;
	newFront.x = sin(MathUtil::Angle2Radian(mYaw)) * cos(MathUtil::Angle2Radian(mPitch));
	newFront.y = sin(MathUtil::Angle2Radian(mPitch));
	newFront.z = -cos(MathUtil::Angle2Radian(mYaw)) * cos(MathUtil::Angle2Radian(mPitch));
	mFront = -newFront.Normalize();
	if (int(abs(mPitch)) % 360 <= 90 || int(abs(mPitch)) % 360 >= 270)
		mRight = mWorldUp.Cross(mFront).Normalize();
	else
		mRight = (-mWorldUp).Cross(mFront).Normalize();
	mUp = mFront.Cross(mRight).Normalize();
}

// This following is generated by Ubpa::USRefl::AutoRefl

RTTR_REGISTRATION
{
	registration::class_<Lumen::Game::Camera>("Camera")
		.constructor<>()
		.constructor<float, float, float, float>()
		.method("Update", &Camera::Update)
		.method("UpdateProjMatrix", &Camera::UpdateProjMatrix)
		.method("ProcessMouseMovement", &Camera::ProcessMouseMovement)
		.method("ProcessKeyboard", &Camera::ProcessKeyboard)
		.method("GetViewMatrix", &Camera::GetViewMatrix)
		.method("GetProjMatrix", &Camera::GetProjMatrix)
		.method("GetViewProjMatrix", &Camera::GetViewProjMatrix)
		.method("SetPos", &Camera::SetPos)
		.method("GetPos", &Camera::GetPos)
		.method("GetNearZ", &Camera::GetNearZ)
		.method("GetFarZ", &Camera::GetFarZ)
		.method("UpdateRotateVector", &Camera::UpdateRotateVector, registration::private_access)
		.property("deviceStatus", &Camera::deviceStatus)
		.property("mViewMatrix", &Camera::mViewMatrix, registration::private_access)
		.property("mProjMatrix", &Camera::mProjMatrix, registration::private_access)
		.property("mViewProjMatrix", &Camera::mViewProjMatrix, registration::private_access)
		.property("mUp", &Camera::mUp, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mFront", &Camera::mFront, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mRight", &Camera::mRight, registration::private_access)
		.property("mWorldUp", &Camera::mWorldUp, registration::private_access)
		.property("mFov", &Camera::mFov, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mAspectRatio", &Camera::mAspectRatio, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mNearPlane", &Camera::mNearPlane, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mFarPlane", &Camera::mFarPlane, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mMoveSpeed", &Camera::mMoveSpeed, registration::private_access)
		(
			metadata("serialize", true)
		)
		.property("mYaw", &Camera::mYaw, registration::private_access)
		.property("mPitch", &Camera::mPitch, registration::private_access)
	;
}